name: Merge Rules from Multiple Sources

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'
  push:
    branches: [ main ]

jobs:
  merge-rules:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Download and merge rules
        run: |
          cat > merge_rules.py << 'EOF'
          #!/usr/bin/env python3
          import requests
          from datetime import datetime

          # 国内规则源列表
          china_rule_sources = [
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/China/China.list",
              "https://raw.githubusercontent.com/blueskycrb/ios_surge/refs/heads/main/cn.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/PayPal/PayPal.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/ChinaASN/ChinaASN.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Microsoft/Microsoft.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/MicrosoftEdge/MicrosoftEdge.list"
          ]

          # 国外规则源列表
          proxy_rule_sources = [
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Telegram/Telegram.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/YouTube/YouTube.list",
              "https://raw.githubusercontent.com/blueskycrb/ios_surge/refs/heads/main/us.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/TikTok/TikTok.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Twitter/Twitter.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Google/Google.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Instagram/Instagram.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Facebook/Facebook.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Proxy/Proxy.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Epic/Epic.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Steam/Steam.list"
          ]

          # AI 规则源列表（你把自己的 AI 链接放这里）
          ai_rule_sources = [
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/OpenAI/OpenAI.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Copilot/Copilot.list",
              "https://raw.githubusercontent.com/blueskycrb/ios_surge/refs/heads/main/AI.list"
          ]


          # mihomo 里 AI 分类默认走哪个策略组名：
          # 1) 你 mihomo 配置里有策略组叫 AI -> 保持 "AI"
          # 2) 不想单独分组 -> 改成 "Proxy"
          AI_POLICY = "AI"

          # 支持的规则类型（Loon/Surge 常见）
          valid_rule_types = {
              "DOMAIN", "DOMAIN-SUFFIX", "DOMAIN-KEYWORD",
              "IP-CIDR", "IP-CIDR6", "PROCESS-NAME",
              "IP-ASN", "USER-AGENT"
          }

          def is_valid_rule(line: str) -> bool:
              line = (line or "").strip()
              if not line or line.startswith("#"):
                  return False

              # 去掉行内注释：DOMAIN,xxx # comment
              if "#" in line:
                  line = line.split("#", 1)[0].strip()
                  if not line:
                      return False

              parts = [p.strip() for p in line.split(",")]
              if len(parts) < 2:
                  return False

              rule_type = parts[0]
              value = parts[1]

              # ✅ 关键修复：第二列不能为空（否则会出现 DOMAIN, / IP-CIDR, 等垃圾规则）
              if rule_type not in valid_rule_types or not value:
                  return False

              # 可选加强：IP-ASN 必须是纯数字，避免 IP-ASN, 这种
              if rule_type == "IP-ASN" and not value.isdigit():
                  return False

              return True

          def has_no_resolve(rule: str) -> bool:
              parts = [p.strip() for p in rule.split(",")]
              return any(p == "no-resolve" for p in parts[2:])

          def format_ip_cidr(rule: str):
              """
              确保 IP-CIDR 单个 IP 会补 /32，同时保留 no-resolve 等额外字段
              遇到 value 为空直接返回 None（避免产生 IP-CIDR,/32 这种错误）
              """
              parts = [p.strip() for p in (rule or "").split(",")]
              if len(parts) < 2:
                  return None

              rule_type = parts[0]
              value = parts[1]
              extra = parts[2:]

              # ✅ value 为空直接丢弃
              if not rule_type or not value:
                  return None

              if rule_type == "IP-CIDR" and "/" not in value:
                  value = f"{value}/32"

              out = [rule_type, value] + extra
              return ",".join(out)

          # ⭐ no-resolve 优先去重：同一个 (TYPE,VALUE) 同时存在时，优先保留带 no-resolve 的那条
          def dedupe_no_resolve_priority(rules):
              base_map = {}
              for raw in rules:
                  formatted = format_ip_cidr(raw)
                  if not formatted:
                      continue
                  rule = formatted

                  parts = [p.strip() for p in rule.split(",")]
                  if len(parts) < 2:
                      continue

                  base_key = f"{parts[0]},{parts[1]}"
                  cur = base_map.get(base_key)
                  if cur is None:
                      base_map[base_key] = rule
                  else:
                      if (not has_no_resolve(cur)) and has_no_resolve(rule):
                          base_map[base_key] = rule

              return set(base_map.values())

          def download_rules(url: str):
              try:
                  print(f"正在下载: {url}")
                  r = requests.get(url, timeout=30)
                  r.raise_for_status()
                  return r.text
              except Exception as e:
                  print(f"下载失败 {url}: {e}")
                  return None

          def parse_rules(content: str, source_url: str):
              """
              兼容：
              - 正常按行规则
              - 偶尔出现“一行塞多条”的情况（用空白切开）
              同时依赖 is_valid_rule 过滤空 value 垃圾规则
              """
              rules = set()
              content = (content or "").replace("\r", "\n")

              for raw_line in content.split("\n"):
                  line = raw_line.strip()
                  if not line or line.startswith("#"):
                      continue

                  # 一行里可能塞了多个规则，用空白拆开逐个判断
                  for token in line.split():
                      if is_valid_rule(token):
                          rules.add(token.strip())

              print(f"从 {source_url} 解析出 {len(rules)} 条规则")
              return rules

          def generate_rule_file(rules, filename: str, name: str):
              sorted_rules = sorted(rules)
              output_lines = [
                  f"# NAME: {name}",
                  f"# DESCRIPTION: {name} rules merged from multiple sources",
                  f"# UPDATED: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                  "",
                  *sorted_rules
              ]
              with open(filename, "w", encoding="utf-8") as f:
                  f.write("\n".join(output_lines))
              print(f"{name} 规则生成完成！总共 {len(sorted_rules)} 条规则 -> {filename}")

          def to_mihomo_rule(rule: str, policy: str) -> str:
              """
              mihomo 规则格式：TYPE,ARGUMENT,POLICY(,no-resolve)
              输入通常是：TYPE,VALUE[,no-resolve]
              """
              parts = [p.strip() for p in rule.split(",")]
              if len(parts) < 2:
                  return ""

              rule_type = parts[0]
              value = parts[1]
              extra = parts[2:]
              nr = any(p == "no-resolve" for p in extra)

              if not rule_type or not value:
                  return ""

              out = f"{rule_type},{value},{policy}"
              if nr:
                  out += ",no-resolve"
              return out

          def generate_mihomo_format(china_rules, proxy_rules, ai_rules):
              mihomo_rules = []

              # 国内：DIRECT
              for rule in china_rules:
                  if rule.startswith("USER-AGENT") or rule.startswith("IP-ASN"):
                      continue
                  r = to_mihomo_rule(rule, "DIRECT")
                  if r:
                      mihomo_rules.append(r)

              # 国外：Proxy
              for rule in proxy_rules:
                  if rule.startswith("USER-AGENT") or rule.startswith("IP-ASN"):
                      continue
                  r = to_mihomo_rule(rule, "Proxy")
                  if r:
                      mihomo_rules.append(r)

              # AI：AI_POLICY（默认 AI，可改 Proxy）
              for rule in ai_rules:
                  if rule.startswith("USER-AGENT") or rule.startswith("IP-ASN"):
                      continue
                  r = to_mihomo_rule(rule, AI_POLICY)
                  if r:
                      mihomo_rules.append(r)

              with open("mihomo.list", "w", encoding="utf-8") as f:
                  f.write("rules:\n")
                  for r in mihomo_rules:
                      f.write(f"  - {r}\n")

              print(f"mihomo 格式规则生成完成！总共 {len(mihomo_rules)} 条规则 -> mihomo.list")

          # === China ===
          print("=== 开始处理国内规则 ===")
          china_rules = set()
          for u in china_rule_sources:
              c = download_rules(u)
              if c:
                  china_rules.update(parse_rules(c, u))
          china_rules = dedupe_no_resolve_priority(china_rules)
          generate_rule_file(china_rules, "china.list", "China")

          # === Proxy ===
          print("=== 开始处理国外规则 ===")
          proxy_rules = set()
          for u in proxy_rule_sources:
              c = download_rules(u)
              if c:
                  proxy_rules.update(parse_rules(c, u))
          proxy_rules = dedupe_no_resolve_priority(proxy_rules)
          generate_rule_file(proxy_rules, "proxy.list", "Proxy")

          # === AI ===
          print("=== 开始处理 AI 规则 ===")
          ai_rules = set()
          for u in ai_rule_sources:
              c = download_rules(u)
              if c:
                  ai_rules.update(parse_rules(c, u))
          ai_rules = dedupe_no_resolve_priority(ai_rules)
          generate_rule_file(ai_rules, "ai.list", "AI")

          # mihomo
          generate_mihomo_format(china_rules, proxy_rules, ai_rules)
          print("所有规则处理完成！")
          EOF

          python -m pip install -U pip
          python -m pip install requests
          python merge_rules.py

      - name: Check generated files
        run: |
          echo "检查生成的文件:"
          ls -la china.list proxy.list ai.list mihomo.list
          echo "---- china.list ----"
          head -5 china.list
          echo "---- proxy.list ----"
          head -5 proxy.list
          echo "---- ai.list ----"
          head -5 ai.list
          echo "---- mihomo.list ----"
          head -10 mihomo.list

      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add china.list proxy.list ai.list mihomo.list
          if git diff --staged --quiet; then
            echo "没有检测到变化"
          else
            git commit -m "Auto-update rules"
            git push
          fi
