name: Merge Rules from Multiple Sources

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'
  push:
    branches: [ main ]

jobs:
  merge-rules:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Download and merge rules
        run: |
          cat > merge_rules.py << 'EOF'
          #!/usr/bin/env python3
          import re
          import requests
          from datetime import datetime

          # 国内规则源列表
          china_rule_sources = [
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/China/China.list",
              "https://raw.githubusercontent.com/blueskycrb/ios_surge/refs/heads/main/cn.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/PayPal/PayPal.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/ChinaASN/ChinaASN.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Microsoft/Microsoft.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/MicrosoftEdge/MicrosoftEdge.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/ChinaMax/ChinaMax.list"
          ]

          # 国外规则源列表
          proxy_rule_sources = [
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Telegram/Telegram.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/YouTube/YouTube.list",
              "https://raw.githubusercontent.com/blueskycrb/ios_surge/refs/heads/main/us.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/TikTok/TikTok.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Twitter/Twitter.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Google/Google.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Instagram/Instagram.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Facebook/Facebook.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Proxy/Proxy.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Epic/Epic.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Steam/Steam.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Proxy/Proxy.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/refs/heads/master/rule/Loon/Proxy/Proxy_Domain.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/ProxyLite/ProxyLite.list"
          ]

          # ✅ AI 规则源列表（把你的链接放这里）
          ai_rule_sources = [
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/OpenAI/OpenAI.list",
              "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Copilot/Copilot.list",
              "https://raw.githubusercontent.com/blueskycrb/ios_surge/refs/heads/main/openai.list"
          ]


          # mihomo 里 AI 分类走哪个策略组名：
          # - 你有单独 AI 策略组：保持 "AI"
          # - 不想单独分组：改成 "Proxy"
          AI_POLICY = "Proxy"

          # 基础规则类型（可转为 mihomo）
          base_rule_types = {
              "DOMAIN", "DOMAIN-SUFFIX", "DOMAIN-KEYWORD",
              "IP-CIDR", "IP-CIDR6", "PROCESS-NAME",
              "IP-ASN", "USER-AGENT"
          }

          # 复合规则类型（只保留到 *.list，不写入 mihomo）
          compound_rule_types = {"AND", "OR", "NOT"}

          # 总允许类型
          valid_rule_types = base_rule_types | compound_rule_types

          def strip_inline_comment(line: str) -> str:
              line = (line or "").strip()
              if not line or line.startswith("#"):
                  return ""
              if "#" in line:
                  line = line.split("#", 1)[0].strip()
              return line

          def normalize_rule(line: str) -> str:
              """
              - 普通规则：按逗号拆分，去掉多余空格，再用逗号拼回去
                例如：'DOMAIN, chatgpt.com' -> 'DOMAIN,chatgpt.com'
                例如：'IP-CIDR, 1.1.1.1/32, no-resolve' -> 'IP-CIDR,1.1.1.1/32,no-resolve'
              - 复合规则（AND/OR/NOT）：只在第一个逗号处分割，保留后面的表达式整体
              """
              line = strip_inline_comment(line)
              if not line:
                  return ""

              rule_type = line.split(",", 1)[0].strip()
              if rule_type in compound_rule_types:
                  # 只 split 一次，保留后面的复杂表达式（里面可能有很多逗号）
                  if "," not in line:
                      return ""
                  rest = line.split(",", 1)[1].strip()
                  if not rest:
                      return ""
                  return f"{rule_type},{rest}"

              parts = [p.strip() for p in line.split(",")]
              parts = [p for p in parts if p != ""]
              if len(parts) < 2:
                  return ""
              return ",".join(parts)

          def is_valid_rule(line: str) -> bool:
              line = strip_inline_comment(line)
              if not line:
                  return False

              rule_type = line.split(",", 1)[0].strip()
              if rule_type not in valid_rule_types:
                  return False

              # 复合规则：只要求第一个逗号后面有内容
              if rule_type in compound_rule_types:
                  if "," not in line:
                      return False
                  rest = line.split(",", 1)[1].strip()
                  return bool(rest)

              # 普通规则：必须至少两列且 value 非空
              parts = [p.strip() for p in line.split(",")]
              if len(parts) < 2:
                  return False
              value = parts[1].strip()
              if not value:
                  return False

              # 加强：IP-ASN 必须是数字
              if rule_type == "IP-ASN" and not value.isdigit():
                  return False

              return True

          def has_no_resolve(rule: str) -> bool:
              parts = [p.strip() for p in rule.split(",")]
              # 复合规则不可能带 no-resolve
              if parts and parts[0] in compound_rule_types:
                  return False
              return any(p == "no-resolve" for p in parts[2:])

          def format_ip_cidr(rule: str):
              """
              - 仅处理 IP-CIDR：单个 IP 没有 / 就补 /32
              - 遇到空 value 直接丢弃（避免 IP-CIDR,/32）
              """
              if not rule:
                  return None
              rule_type = rule.split(",", 1)[0].strip()
              if rule_type in compound_rule_types:
                  return rule  # 复合规则原样返回

              parts = [p.strip() for p in rule.split(",")]
              if len(parts) < 2:
                  return None
              rule_type = parts[0]
              value = parts[1]
              extra = parts[2:]

              if not rule_type or not value:
                  return None

              if rule_type == "IP-CIDR" and "/" not in value:
                  value = f"{value}/32"

              out = [rule_type, value] + extra
              return ",".join(out)

          # ⭐ no-resolve 优先去重：同一个 (TYPE,VALUE) 同时存在时，优先保留带 no-resolve 的那条
          def dedupe_no_resolve_priority(rules):
              base_map = {}
              for raw in rules:
                  formatted = format_ip_cidr(raw)
                  if not formatted:
                      continue
                  rule = formatted

                  rule_type = rule.split(",", 1)[0].strip()

                  # 复合规则：用整行做 key（不做 no-resolve 优先逻辑）
                  if rule_type in compound_rule_types:
                      base_map[rule] = rule
                      continue

                  parts = [p.strip() for p in rule.split(",")]
                  if len(parts) < 2:
                      continue

                  base_key = f"{parts[0]},{parts[1]}"
                  cur = base_map.get(base_key)
                  if cur is None:
                      base_map[base_key] = rule
                  else:
                      if (not has_no_resolve(cur)) and has_no_resolve(rule):
                          base_map[base_key] = rule

              return set(base_map.values())

          def download_rules(url: str):
              try:
                  print(f"正在下载: {url}")
                  r = requests.get(url, timeout=30)
                  r.raise_for_status()
                  return r.text
              except Exception as e:
                  print(f"下载失败 {url}: {e}")
                  return None

          def split_multi_rules_in_line(line: str):
              """
              兼容极端情况：一行塞多个规则，例如：
              'DOMAIN, a.com DOMAIN-SUFFIX, b.com'
              注意：带空格的标准写法 'DOMAIN, a.com' 也能正确处理。
              复合规则 AND/OR/NOT 不做拆分（避免拆坏表达式）。
              """
              line = line.strip()
              if not line:
                  return []

              first_type = line.split(",", 1)[0].strip()
              if first_type in compound_rule_types:
                  return [line]

              # 在行里找每个规则的起点：<TYPE>,
              type_pattern = "|".join(re.escape(t) for t in sorted(base_rule_types, key=len, reverse=True))
              pattern = re.compile(rf"(?<!\S)({type_pattern})\s*,")
              matches = list(pattern.finditer(line))
              if len(matches) <= 1:
                  return [line]

              segs = []
              for i, m in enumerate(matches):
                  start = m.start()
                  end = matches[i + 1].start() if i + 1 < len(matches) else len(line)
                  seg = line[start:end].strip()
                  if seg:
                      segs.append(seg)
              return segs

          def parse_rules(content: str, source_url: str):
              rules = set()
              content = (content or "").replace("\r", "\n")

              for raw_line in content.split("\n"):
                  line = strip_inline_comment(raw_line)
                  if not line:
                      continue

                  for seg in split_multi_rules_in_line(line):
                      seg = seg.strip()
                      if not seg:
                          continue
                      if is_valid_rule(seg):
                          norm = normalize_rule(seg)
                          if norm and is_valid_rule(norm):
                              rules.add(norm)

              print(f"从 {source_url} 解析出 {len(rules)} 条规则")
              return rules

          def generate_rule_file(rules, filename: str, name: str):
              sorted_rules = sorted(rules)
              output_lines = [
                  f"# NAME: {name}",
                  f"# DESCRIPTION: {name} rules merged from multiple sources",
                  f"# UPDATED: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                  "",
                  *sorted_rules
              ]
              with open(filename, "w", encoding="utf-8") as f:
                  f.write("\n".join(output_lines))
              print(f"{name} 规则生成完成！总共 {len(sorted_rules)} 条规则 -> {filename}")

          def to_mihomo_rule(rule: str, policy: str) -> str:
              """
              mihomo 规则格式：TYPE,ARGUMENT,POLICY(,no-resolve)
              这里只转换基础规则类型，复合 AND/OR/NOT 直接跳过。
              """
              rule_type = rule.split(",", 1)[0].strip()
              if rule_type in compound_rule_types:
                  return ""

              parts = [p.strip() for p in rule.split(",")]
              if len(parts) < 2:
                  return ""

              rule_type = parts[0]
              value = parts[1]
              extra = parts[2:]
              if not rule_type or not value:
                  return ""

              nr = any(p == "no-resolve" for p in extra)
              out = f"{rule_type},{value},{policy}"
              if nr:
                  out += ",no-resolve"
              return out

          def generate_mihomo_format(china_rules, proxy_rules, ai_rules):
              mihomo_rules = []

              # 国内：DIRECT
              for rule in china_rules:
                  if rule.startswith("USER-AGENT") or rule.startswith("IP-ASN"):
                      continue
                  r = to_mihomo_rule(rule, "DIRECT")
                  if r:
                      mihomo_rules.append(r)

              # 国外：Proxy
              for rule in proxy_rules:
                  if rule.startswith("USER-AGENT") or rule.startswith("IP-ASN"):
                      continue
                  r = to_mihomo_rule(rule, "Proxy")
                  if r:
                      mihomo_rules.append(r)

              # AI：AI_POLICY
              for rule in ai_rules:
                  if rule.startswith("USER-AGENT") or rule.startswith("IP-ASN"):
                      continue
                  r = to_mihomo_rule(rule, AI_POLICY)
                  if r:
                      mihomo_rules.append(r)

              with open("mihomo.list", "w", encoding="utf-8") as f:
                  f.write("rules:\n")
                  for r in mihomo_rules:
                      f.write(f"  - {r}\n")

              print(f"mihomo 格式规则生成完成！总共 {len(mihomo_rules)} 条规则 -> mihomo.list")

          # === China ===
          print("=== 开始处理国内规则 ===")
          china_rules = set()
          for u in china_rule_sources:
              c = download_rules(u)
              if c:
                  china_rules.update(parse_rules(c, u))
          china_rules = dedupe_no_resolve_priority(china_rules)
          generate_rule_file(china_rules, "china.list", "China")

          # === Proxy ===
          print("=== 开始处理国外规则 ===")
          proxy_rules = set()
          for u in proxy_rule_sources:
              c = download_rules(u)
              if c:
                  proxy_rules.update(parse_rules(c, u))
          proxy_rules = dedupe_no_resolve_priority(proxy_rules)
          generate_rule_file(proxy_rules, "proxy.list", "Proxy")

          # === AI ===
          print("=== 开始处理 AI 规则 ===")
          ai_rules = set()
          for u in ai_rule_sources:
              c = download_rules(u)
              if c:
                  ai_rules.update(parse_rules(c, u))
          ai_rules = dedupe_no_resolve_priority(ai_rules)
          generate_rule_file(ai_rules, "ai.list", "AI")

          # mihomo
          generate_mihomo_format(china_rules, proxy_rules, ai_rules)
          print("所有规则处理完成！")
          EOF

          python -m pip install -U pip
          python -m pip install requests
          python merge_rules.py

      - name: Check generated files
        run: |
          echo "检查生成的文件:"
          ls -la china.list proxy.list ai.list mihomo.list
          echo "---- ai.list (前30行) ----"
          head -30 ai.list
          echo "---- mihomo.list (前30行) ----"
          head -30 mihomo.list

      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add china.list proxy.list ai.list mihomo.list
          if git diff --staged --quiet; then
            echo "没有检测到变化"
          else
            git commit -m "Auto-update rules"
            git push
          fi
